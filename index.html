<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="favicon.ico" type="image/x-icon" sizes="48x48">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1f1f1f">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeLorme Finder</title>
    <style>
        /* --- CSS STYLES --- */
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            text-align: center;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background-color: #1f1f1f;
            padding: 15px;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { margin: 0; font-size: 1.2rem; color: #bb86fc; }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .install-btn {
            display: none; /* Hidden by default */
            background-color: #03dac6;
            color: #000;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .settings-btn {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0 10px;
        }

        .container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 0 60px 0;
            width: 100%;
        }

        .coords-box {
            font-family: "Courier New", Courier, monospace;
            font-size: 1.2rem;
            color: #03dac6;
            margin-top: 10px;
            margin-bottom: 20px;
            background: #1e1e1e;
            padding: 10px;
            border-radius: 8px;
            width: 90%;
            border: 1px solid #333;
        }

        .result-box {
            width: 100%;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-grow: 1;
        }

        .grid-label { font-size: 1.5rem; color: #888; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 2px; }
        .page-value { font-size: 4.5rem; font-weight: 800; margin-bottom: 30px; line-height: 1; color: #ffffff; }

        footer {
            background-color: #1f1f1f;
            padding: 10px 20px;
            font-size: 0.8rem;
            color: #888;
            border-top: 2px solid #333;
            display: flex;
            justify-content: space-between;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            box-sizing: border-box;
            z-index: 1000;
        }

        /* --- MENU OVERLAY STYLES --- */
        .menu-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.9);
            z-index: 2000;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .menu-content {
            background: #1e1e1e;
            width: 85%;
            max-width: 400px;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #333;
            max-height: 80vh;       
            display: flex;          
            flex-direction: column; 
        }

        .menu-title { 
            font-size: 1.5rem; 
            color: #bb86fc; 
            margin-bottom: 10px; 
            flex-shrink: 0;      
        }

        /* Auto Mode Toggle Row */
        .auto-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 8px;
            margin-bottom: 10px;
            box-sizing: border-box;
            border: 1px solid #bb86fc;
            flex-shrink: 0;
        }
        
        .auto-label { font-size: 1rem; color: #ffffff; font-weight: bold; }

        /* The Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .switch input { opacity: 0; width: 0; height: 0; }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider { background-color: #bb86fc; }
        input:checked + .slider:before { transform: translateX(22px); }


        #mapList {
            overflow-y: auto;       
            flex-grow: 1;           
            margin-bottom: 15px;    
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }

        .map-option {
            display: flex;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #333;
            font-size: 1.2rem;
        }

        .map-option input { transform: scale(1.5); margin-right: 15px; }

        .deselect-btn {
            background: transparent;
            border: none;
            color: #cf6679; 
            font-size: 0.9rem;
            cursor: pointer;
            margin-bottom: 5px;
            align-self: flex-end; 
            text-decoration: underline;
            flex-shrink: 0;
        }
        
        .load-btn {
            background-color: #bb86fc;
            color: #000;
            border: none;
            padding: 15px;
            width: 100%;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 5px;
            margin-top: 10px;
            cursor: pointer;
            flex-shrink: 0;
        }

      .cache-btn {
            background: transparent;
            color: #03dac6;
            border: 1px solid #03dac6;
            padding: 10px;
            width: 100%;
            margin-top: 10px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn {
            background: transparent;
            color: #888;
            border: 1px solid #888;
            padding: 10px;
            width: 100%;
            margin-top: 10px;
            border-radius: 5px;
            flex-shrink: 0;
        }

        .blink { animation: blinker 1s linear infinite; color: #03dac6; }
        @keyframes blinker { 50% { opacity: 0; } }
        .error { color: #cf6679; }
        .loading { color: #bb86fc; font-size: 1.5rem; }

        .status-dot { 
            height: 10px; 
            width: 10px; 
            background-color: #03dac6; /* Teal color */
            border-radius: 50%; 
            margin-right: 15px; 
            box-shadow: 0 0 5px #03dac6;
        }
        
        .auto-item { 
            color: #fff; 
            cursor: default; 
            opacity: 1 !important; /* Force opacity override */
        }

        .auto-empty {
            padding: 20px;
            text-align: center;
            color: #888;
            font-style: italic;
        }
    </style>
</head>
<body>

    <header>
        <h1>DeLorme Finder</h1>
        <div class="header-buttons">
            <!-- Hidden by default, shown via JS if installable -->
            <button id="installBtn" class="install-btn" onclick="installPWA()">⬇️ Install</button>
            <button class="settings-btn" onclick="openMenu()">⚙️</button>
        </div>
    </header>

    <div class="container">
        <div class="coords-box">
            <div id="latDisp">Initializing...</div>
            <div id="lonDisp"></div>
        </div>

        <div id="resultContainer" class="result-box">
            <span style="font-size: 1.2rem; color: #555;">No Maps Loaded</span>
        </div>
    </div>

    <!-- MENU OVERLAY -->
    <div id="menuOverlay" class="menu-overlay">
        <div class="menu-content">
            <div class="menu-title">Settings</div>
            
            <!-- AUTO TOGGLE -->
            <div class="auto-row">
                <span class="auto-label">Auto-Load State</span>
                <label class="switch">
                    <input type="checkbox" id="autoToggle" onchange="toggleAutoMode()">
                    <span class="slider"></span>
                </label>
            </div>

            <button class="deselect-btn" id="deselectBtn" onclick="deselectAll()">Uncheck All</button>
            
            <div id="mapList">
                <!-- Javascript will inject checkboxes here -->
            </div>
            
            <button class="load-btn" id="loadBtn" onclick="loadSelectedMaps()">LOAD SELECTED</button>
            <button class="cache-btn" onclick="downloadAllForOffline()">Download All Maps (Offline)</button>
            <div id="downloadStatus" style="text-align: center; color: #03dac6; margin-top: 5px;"></div>
            <button class="close-btn" onclick="closeMenu()">Close</button>
        </div>
    </div>

    <footer>
        <span id="accuracy">Acc: -- m</span>
        <span id="clock">--:--:--</span>
        <span><span id="heartbeat" class="blink">●</span></span>
    </footer>

    <script>
        // --- 1. CONFIGURATION ---
        // 'codes': array of state codes that this file belongs to. Used for Auto Mode.
        const availableMapFiles = [
            { file: "alabama.json", label: "Alabama Counties", codes: ["AL"] },
            { file: "AL.json", label: "Alabama Delorme", codes: ["AL"] },
            { file: "alaska.json", label: "Alaska Counties", codes: ["AK"] },
            { file: "AK.json", label: "Alaska Delorme", codes: ["AK"] },
            { file: "arizona.json", label: "Arizona Counties", codes: ["AZ"] },
            { file: "AZ.json", label: "Arizona Delorme", codes: ["AZ"] },
            { file: "arkansas.json", label: "Arkansas Counties", codes: ["AR"] },
            { file: "AR.json", label: "Arkansas Delorme", codes: ["AR"] },
            { file: "AR2.json", label: "Arkansas Delorme 2", codes: ["AR"] },
            { file: "california.json", label: "California Counties", codes: ["CA"] },
            { file: "CN.json", label: "NorCal Delorme", codes: ["CA"] },
            { file: "CS.json", label: "SoCal Delorme", codes: ["CA"] },
            { file: "CA.json", label: "Golden State", codes: ["CA"] },
            { file: "colorado.json", label: "Colorado Counties", codes: ["CO"] },
            { file: "CO.json", label: "Colorado Delorme", codes: ["CO"] },
            { file: "connecticut.json", label: "Connecticut Counties", codes: ["CT"] },
            { file: "CT.json", label: "Connecticut Delorme", codes: ["CT"] },
            { file: "delaware.json", label: "Delaware Counties", codes: ["DE"] },
            { file: "DE.json", label: "Delaware Delorme", codes: ["DE"] },
            { file: "florida.json", label: "Florida Counties", codes: ["FL"] },
            { file: "FL.json", label: "Florida Delorme", codes: ["FL"] },
            { file: "FL2.json", label: "Florida Delorme 2", codes: ["FL"] },
            { file: "georgia.json", label: "Georgia Counties", codes: ["GA"] },
            { file: "GA.json", label: "Georgia Delorme", codes: ["GA"] },
            { file: "hawaii.json", label: "Hawaii Counties", codes: ["HI"] },
            { file: "HI.json", label: "Hawaii Delorme", codes: ["HI"] },
            { file: "idaho.json", label: "Idaho Counties", codes: ["ID"] },
            { file: "ID.json", label: "Idaho Delorme", codes: ["ID"] },
            { file: "illinois.json", label: "Illinois Counties", codes: ["IL"] },
            { file: "IL.json", label: "Illinois Delorme", codes: ["IL"] },
            { file: "indiana.json", label: "Indiana Counties", codes: ["IN"] },
            { file: "IN.json", label: "Indiana Delorme", codes: ["IN"] },
            { file: "iowa.json", label: "Iowa Counties", codes: ["IA"] },
            { file: "IA.json", label: "Iowa Delorme", codes: ["IA"] },
            { file: "kansas.json", label: "Kansas Counties", codes: ["KS"] },
            { file: "KS.json", label: "Kansas Delorme", codes: ["KS"] },
            { file: "kentucky.json", label: "Kentucky Counties", codes: ["KY"] },
            { file: "KY.json", label: "Kentucky Delorme", codes: ["KY"] },
            { file: "louisiana.json", label: "Louisiana Parishes", codes: ["LA"] },
            { file: "LA.json", label: "Louisiana Delorme", codes: ["LA"] },
            { file: "maine.json", label: "Maine Counties", codes: ["ME"] },
            { file: "ME.json", label: "Maine Delorme", codes: ["ME"] },
            { file: "maryland.json", label: "Maryland Counties", codes: ["MD"] },
            { file: "MD.json", label: "Maryland Delorme", codes: ["MD"] },
            { file: "massachusetts.json", label: "Massachusetts Counties", codes: ["MA"] },
            { file: "MA.json", label: "Massachusetts Delorme", codes: ["MA"] },
            { file: "michigan.json", label: "Michigan Counties", codes: ["MI"] },
            { file: "MI.json", label: "Michigan Delorme", codes: ["MI"] },
            { file: "minnesota.json", label: "Minnesota Counties", codes: ["MN"] },
            { file: "MN.json", label: "Minnesota Delorme", codes: ["MN"] },
            { file: "MN2.json", label: "Minnesota Delorme 2", codes: ["MN"] },
            { file: "mississippi.json", label: "Mississippi Counties", codes: ["MS"] },
            { file: "MS.json", label: "Mississippi Delorme", codes: ["MS"] },
            { file: "missouri.json", label: "Missouri Counties", codes: ["MO"] },
            { file: "MO.json", label: "Missouri Delorme", codes: ["MO"] },
            { file: "montana.json", label: "Montana Counties", codes: ["MT"] },
            { file: "MT.json", label: "Montana Delorme", codes: ["MT"] },
            { file: "nebraska.json", label: "Nebraska Counties", codes: ["NE"] },
            { file: "NE.json", label: "Nebraska Delorme", codes: ["NE"] },
            { file: "nevada.json", label: "Nevada Counties", codes: ["NV"] },
            { file: "NV.json", label: "Nevada Delorme", codes: ["NV"] },
            { file: "new_hampshire.json", label: "New Hampshire Counties", codes: ["NH"] },
            { file: "NH.json", label: "New Hampshire Delorme", codes: ["NH"] },
            { file: "new_jersey.json", label: "New Jersey Counties", codes: ["NJ"] },
            { file: "NJ.json", label: "New Jersey Delorme", codes: ["NJ"] },
            { file: "new_mexico.json", label: "New Mexico Counties", codes: ["NM"] },
            { file: "NM.json", label: "New Mexico Delorme", codes: ["NM"] },
            { file: "new_york.json", label: "New York Counties", codes: ["NY"] },
            { file: "NY.json", label: "New York Delorme", codes: ["NY"] },
            { file: "north_carolina.json", label: "North Carolina Counties", codes: ["NC"] },
            { file: "NC.json", label: "North Carolina Delorme", codes: ["NC"] },
            { file: "north_dakota.json", label: "North Dakota Counties", codes: ["ND"] },
            { file: "ND.json", label: "North Dakota Delorme", codes: ["ND"] },
            { file: "ohio.json", label: "Ohio Counties", codes: ["OH"] },
            { file: "OH.json", label: "Ohio Delorme", codes: ["OH"] },
            { file: "oklahoma.json", label: "Oklahoma Counties", codes: ["OK"] },
            { file: "OK.json", label: "Oklahoma Delorme", codes: ["OK"] },
            { file: "oregon.json", label: "Oregon Counties", codes: ["OR"] },
            { file: "OR.json", label: "Oregon Delorme", codes: ["OR"] },
            { file: "pennsylvania.json", label: "Pennsylvania Counties", codes: ["PA"] },
            { file: "PA.json", label: "Pennsylvania Delorme", codes: ["PA"] },
            { file: "rhode_island.json", label: "Rhode Island Counties", codes: ["RI"] },
            { file: "RI.json", label: "Rhode Island Delorme", codes: ["RI"] },
            { file: "south_carolina.json", label: "South Carolina Counties", codes: ["SC"] },
            { file: "SC.json", label: "South Carolina Delorme", codes: ["SC"] },
            { file: "south_dakota.json", label: "South Dakota Counties", codes: ["SD"] },
            { file: "SD.json", label: "South Dakota Delorme", codes: ["SD"] },
            { file: "tennessee.json", label: "Tennessee Counties", codes: ["TN"] },
            { file: "TN.json", label: "Tennessee Delorme", codes: ["TN"] },
            { file: "texas.json", label: "Texas Counties", codes: ["TX"] },
            { file: "TX.json", label: "Texas Delorme", codes: ["TX"] },
            { file: "utah.json", label: "Utah Counties", codes: ["UT"] },
            { file: "UT.json", label: "Utah Delorme", codes: ["UT"] },
            { file: "UT2.json", label: "Utah Delorme 2", codes: ["UT"] },
            { file: "vermont.json", label: "Vermont Counties", codes: ["VT"] },
            { file: "VT.json", label: "Vermont Delorme", codes: ["VT"] },
            { file: "virginia.json", label: "Virginia Counties", codes: ["VA"] },
            { file: "VA.json", label: "Virginia Delorme", codes: ["VA"] },
            { file: "washington.json", label: "Washington Counties", codes: ["WA"] },
            { file: "WA.json", label: "Washington Delorme", codes: ["WA"] },
            { file: "west_virginia.json", label: "West Virginia Counties", codes: ["WV"] },
            { file: "WV.json", label: "West Virginia Delorme", codes: ["WV"] },
            { file: "wisconsin.json", label: "Wisconsin Counties", codes: ["WI"] },
            { file: "WI.json", label: "Wisconsin Delorme", codes: ["WI"] },
            { file: "WI2.json", label: "Wisconsin Delorme 2", codes: ["WI"] },
            { file: "wyoming.json", label: "Wyoming Counties", codes: ["WY"] },
            { file: "WY.json", label: "Wyoming Delorme", codes: ["WY"] },
            { file: "WY2.json", label: "Wyoming Delorme 2", codes: ["WY"] }
        ];

        // Global variables
        let gridCollections = [];
        let stateBoundaries = [];
        let isAutoMode = false;
        let currentlyLoadedStateCodes = [];

        // --- 2. STARTUP ---
        
        async function loadStateBoundaries() {
            try {
                const res = await fetch("maps/states.json");
                if(res.ok) {
                    const json = await res.json();
                    stateBoundaries = json.data; 
                    console.log("State boundaries loaded");
                }
            } catch (e) {
                console.log("Could not load states.json");
            }
        }

        function initMenu() {
            // This now only renders the MANUAL checkbox list
            const listDiv = document.getElementById('mapList');
            let html = '';
            
            availableMapFiles.forEach((map, index) => {
                const isChecked = localStorage.getItem(map.file) === 'true' ? 'checked' : '';
                html += `
                    <label class="map-option">
                        <input type="checkbox" id="map_${index}" value="${map.file}" ${isChecked}>
                        ${map.label}
                    </label>
                `;
            });
            listDiv.innerHTML = html;
        }

        function renderAutoList() {
            const listDiv = document.getElementById('mapList');
            let html = '';
            
            // Filter the master list to find maps that match currently loaded State Codes
            const activeMaps = availableMapFiles.filter(map => {
                if (!map.codes) return false;
                return map.codes.some(c => currentlyLoadedStateCodes.includes(c));
            });

            if (activeMaps.length === 0) {
                html = '<div class="auto-empty">Waiting for GPS location...<br>or no maps for this area.</div>';
            } else {
                activeMaps.forEach(map => {
                    html += `
                        <div class="map-option auto-item">
                            <span class="status-dot"></span>
                            ${map.label}
                        </div>
                    `;
                });
            }
            listDiv.innerHTML = html;
        }

        function toggleAutoMode() {
            const toggle = document.getElementById('autoToggle');
            isAutoMode = toggle.checked;
            localStorage.setItem('isAutoMode', isAutoMode);
            
            const list = document.getElementById('mapList');
            const loadBtn = document.getElementById('loadBtn');
            const deselectBtn = document.getElementById('deselectBtn');

            if (isAutoMode) {
                // --- AUTO MODE UI ---
                // 1. Restore opacity (it was dimmed in previous version)
                list.style.opacity = "1";
                list.style.pointerEvents = "auto";
                
                // 2. Hide manual buttons
                loadBtn.style.display = 'none'; 
                deselectBtn.style.display = 'none';
                
                // 3. Show "Active Maps" list instead of checkboxes
                renderAutoList();
                
                // 4. Trigger Auto Logic
                if (!window.gpsStarted) {
                    startApp();
                    window.gpsStarted = true;
                }
                document.getElementById('resultContainer').innerHTML = '<span class="loading">Auto Mode On<br>Scanning...</span>';
                
            } else {
                // --- MANUAL MODE UI ---
                loadBtn.style.display = 'block';
                deselectBtn.style.display = 'block';
                
                // Restore Checkbox List
                initMenu();
                
                // Clear Auto data
                currentlyLoadedStateCodes = [];
                gridCollections = []; // Clear maps until user hits Load
                document.getElementById('resultContainer').innerHTML = '<span style="color:#555">Manual Mode<br>Select maps</span>';
            }
        }

        async function checkAutoLoad(lat, lon) {
            if (!isAutoMode || stateBoundaries.length === 0) return;

            // 1. Find which states we are in
            const detectedCodes = [];
            
            for(let i=0; i<stateBoundaries.length; i++) {
                const entry = stateBoundaries[i];
                // entry: [minLat, maxLat, minLon, maxLon, "CODE", (optional poly)]
                const minLat = Math.min(entry[0], entry[1]);
                const maxLat = Math.max(entry[0], entry[1]);
                const minLon = Math.min(entry[2], entry[3]);
                const maxLon = Math.max(entry[2], entry[3]);

                if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {
                    detectedCodes.push(entry[4]);
                }
            }

            // 2. Compare with what is currently loaded
            detectedCodes.sort();
            const currentStr = currentlyLoadedStateCodes.sort().join(",");
            const newStr = detectedCodes.join(",");

            // 3. If different, LOAD files
            if (currentStr !== newStr) {
                console.log("State change detected: " + newStr);
                currentlyLoadedStateCodes = detectedCodes;
                
                const resultDiv = document.getElementById('resultContainer');
                
                if (detectedCodes.length === 0) {
                     gridCollections = [];
                     resultDiv.innerHTML = '<span style="color:#555">No maps for this location</span>';
                     return;
                }

                resultDiv.innerHTML = `<span class="loading">Entering ${newStr}...<br>Loading Maps</span>`;

                // Find files that match these codes
                const filesToLoad = [];
                availableMapFiles.forEach(map => {
                    if (map.codes) {
                        const match = map.codes.some(c => detectedCodes.includes(c));
                        if (match) filesToLoad.push(map.file);
                    }
                });

                if (filesToLoad.length > 0) {
                    try {
                        const promises = filesToLoad.map(file => fetch("maps/" + file).then(res => res.json()));
                        gridCollections = await Promise.all(promises);
                        // Refresh display immediately
                        findPages(lat, lon);
                        if(document.getElementById('menuOverlay').style.display === 'flex') {
                        renderAutoList(); // Update menu if it's open
                        }
                    } catch(e) {
                         resultDiv.innerHTML = `<span class="error">Error loading auto maps</span>`;
                    }
                } else {
                    gridCollections = [];
                    resultDiv.innerHTML = '<span style="color:#555">No map files found for code: ' + newStr + '</span>';
                }
            }
        }

        // --- 4. MANUAL MENU FUNCTIONS ---

        function openMenu() {
            // Force a refresh of the list every time the menu is opened
            if (isAutoMode) {
                renderAutoList();
            } else {
                // Optional: You can re-render manual list here if needed, 
                // but usually manual list state is preserved in DOM.
                // If you notice manual checkboxes resetting unexpectedly, 
                // you can uncomment the line below:
                // initMenu(); 
            }
            document.getElementById('menuOverlay').style.display = 'flex';
        }

        function closeMenu() {
            document.getElementById('menuOverlay').style.display = 'none';
        }

        function deselectAll() {
            availableMapFiles.forEach((_, index) => {
                const checkbox = document.getElementById(`map_${index}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
        }

        async function loadSelectedMaps() {
            if (isAutoMode) return;

            closeMenu();
            const resultDiv = document.getElementById('resultContainer');
            resultDiv.innerHTML = '<span class="loading">Loading...</span>';

            const filesToLoad = [];
            
            // Find checked boxes
            availableMapFiles.forEach((map, index) => {
                const checkbox = document.getElementById(`map_${index}`);
                if (checkbox && checkbox.checked) {
                    filesToLoad.push(map.file);
                    localStorage.setItem(map.file, 'true'); 
                } else {
                    localStorage.setItem(map.file, 'false');
                }
            });

            if (filesToLoad.length === 0) {
                resultDiv.innerHTML = '<span style="color: #555;">No Maps Selected</span>';
                gridCollections = [];
                return;
            }

            try {
                const promises = filesToLoad.map(file => fetch("maps/" + file).then(res => {
                    if (!res.ok) throw new Error(`Failed: ${file}`);
                    return res.json();
                }));

                gridCollections = await Promise.all(promises);
                resultDiv.innerHTML = '<span style="font-size: 1.5rem; color: #555;">Waiting for GPS...</span>';
                
                if (!window.gpsStarted) {
                    startApp();
                    window.gpsStarted = true;
                }

            } catch (err) {
                resultDiv.innerHTML = `<span class="error">Error:<br>${err.message}</span>`;
            }
        }

        // --- 5. GPS LOGIC ---

        function startApp() {
            if ("geolocation" in navigator) {
                navigator.geolocation.watchPosition(updateLocation, handleError, {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                });
            } else {
                document.getElementById('latDisp').innerText = "GPS Not Supported";
            }
            
            setInterval(updateClock, 1000);
            requestWakeLock();
        }

        function updateLocation(position) {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            const acc = position.coords.accuracy;

            document.getElementById('latDisp').innerHTML = toDDM(lat, true);
            document.getElementById('lonDisp').innerHTML = toDDM(lon, false);
            document.getElementById('accuracy').innerText = `Acc: ±${Math.round(acc)}m`;

            if (isAutoMode) {
                checkAutoLoad(lat, lon);
            }

            if (gridCollections.length > 0) {
                findPages(lat, lon);
            }
        }

        function findPages(lat, lon) {
            const resultDiv = document.getElementById('resultContainer');
            let foundHtml = "";
            let matchesFound = false;

            gridCollections.forEach(collection => {
                const gridName = collection.name;
                const gridData = collection.data;

                for (let i = 0; i < gridData.length; i++) {
                    const entry = gridData[i];
                    
                    // 1. FAST CHECK: Bounding Box
                    const minLat = Math.min(entry[0], entry[1]);
                    const maxLat = Math.max(entry[0], entry[1]);
                    const minLon = Math.min(entry[2], entry[3]);
                    const maxLon = Math.max(entry[2], entry[3]);

                    if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {
                        
                        // 2. DETAILED CHECK: Polygon
                        let isMatch = true;
                        if (entry[5] && Array.isArray(entry[5])) {
                            if (!isPointInPolygon(lat, lon, entry[5])) {
                                isMatch = false;
                            }
                        }

                        if (isMatch) {
                            const pageName = entry[4];
                            foundHtml += `
                                <div class="grid-label">${gridName}</div>
                                <div class="page-value">${pageName}</div>
                            `;
                            matchesFound = true;
                        }
                    }
                }
            });

            if (matchesFound) {
                resultDiv.innerHTML = foundHtml;
            } else {
                resultDiv.innerHTML = '<span style="font-size: 1.5rem; color: #555;">No Page Found</span>';
            }
        }

        // --- 6. HELPERS ---

        function isPointInPolygon(lat, lon, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];

                const intersect = ((yi > lon) != (yj > lon)) &&
                    (lat < (xj - xi) * (lon - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        function toDDM(val, isLat) {
            const dir = isLat ? (val >= 0 ? 'N' : 'S') : (val >= 0 ? 'E' : 'W');
            val = Math.abs(val);
            const deg = Math.floor(val);
            const min = (val - deg) * 60;
            
            let degStr = deg.toString();
            if (deg < 100) degStr = "&nbsp;" + degStr;
            if (deg < 10) degStr = "&nbsp;" + degStr;

            let minStr = min.toFixed(3);
            if (min < 10) minStr = "0" + minStr;

            return `${dir} ${degStr} ${minStr}`;
        }

        function updateClock() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour12: false });
            document.getElementById('clock').innerText = timeStr;
        }

        function handleError(error) {
            document.getElementById('latDisp').innerHTML = "<span class='error'>GPS Error</span>";
            document.getElementById('lonDisp').innerText = error.message;
        }
        
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) await navigator.wakeLock.request('screen');
            } catch (err) { console.log("Wake Lock error:", err); }
        }

        async function downloadAllForOffline() {
            const statusDiv = document.getElementById('downloadStatus');
            statusDiv.innerText = "Starting download...";
            
            // 1. Get list of all URLs to fetch
            const urlsToCache = [
                "maps/states.json",
                ...availableMapFiles.map(m => "maps/" + m.file)
            ];

            let count = 0;
            const total = urlsToCache.length;

            // 2. Fetch them one by one (Service Worker will capture and save them)
            // We use a loop to avoid freezing the browser with 100 simultaneous requests
            for (const url of urlsToCache) {
                try {
                    await fetch(url);
                    count++;
                    statusDiv.innerText = `Cached ${count} / ${total}`;
                } catch (e) {
                    console.log("Failed to cache " + url);
                }
            }
            
            statusDiv.innerText = "All Maps Saved Offline!";
            setTimeout(() => { statusDiv.innerText = ""; }, 3000);
        }

// --- PWA INSTALL LOGIC ---
        let deferredPrompt;

        window.addEventListener('beforeinstallprompt', (e) => {
            // 1. Prevent Chrome 67+ from automatically showing the prompt
            e.preventDefault();
            // 2. Stash the event so it can be triggered later
            deferredPrompt = e;
            // 3. Show the install button
            document.getElementById('installBtn').style.display = 'block';
        });

        async function installPWA() {
            if (!deferredPrompt) return;
            
            // Show the install prompt
            deferredPrompt.prompt();
            
            // Wait for the user to respond to the prompt
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`User response to install prompt: ${outcome}`);
            
            // We've used the prompt, and can't use it again, discard it
            deferredPrompt = null;
            
            // Hide the button
            document.getElementById('installBtn').style.display = 'none';
        }

        // Hide button if app is already installed (standalone mode)
        window.addEventListener('appinstalled', () => {
            document.getElementById('installBtn').style.display = 'none';
            deferredPrompt = null;
        });

// --- 7. INITIALIZATION ---

        loadStateBoundaries();

        // 1. Check LocalStorage. If null (first visit), default to TRUE.
        const savedSetting = localStorage.getItem('isAutoMode');
        const savedAuto = savedSetting === null ? true : (savedSetting === 'true');
        
        // 2. Apply Setting
        document.getElementById('autoToggle').checked = savedAuto;
        isAutoMode = savedAuto; 
        
        // 3. Initialize UI (Draws the correct list based on mode)
        toggleAutoMode(); 
        
        // 4. Start Logic
        if (!savedAuto) {
            // Manual Mode: Load saved selection
            // We call initMenu here just to be safe, though toggleAutoMode did it too.
            initMenu(); 
            loadSelectedMaps();
        } else {
             // Auto Mode: Start GPS immediately
             // REMOVED: initMenu();  <-- This was the bug causing checkboxes to appear!
             startApp();
             window.gpsStarted = true;
        }

// --- PWA SETUP ---
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('Service Worker Registered'));
        }
      
    </script>
</body>
</html>
